enum tier {
  free_trial [note: 'Free Trial tier will get their infras data wiped after 30 days']
  bronze
  silver
  gold
  platinum [note: 'Platinum tier will get their own dedicated infra']
}

enum source_engine {
  mysql
  postgresql
}

enum destination_engine {
  mysql
  postgresql
}

Table tenants {
  id UUID [pk]
  name varchar(255)
  domain varchar(255)
  tier tier
  infra_id UUID [ref: > tenant_infras.id]

  created_at timestamp
  updated_at timestamp
}

Table users {
  id UUID [pk]

  created_at timestamp
  updated_at timestamp
}

Table tenant_users {
  tenant_id UUID [ref: > tenants.id]
  user_id UUID [ref: > users.id]

  created_at timestamp
  updated_at timestamp

  indexes {
    (user_id, tenant_id) [pk]
  }
}

Table tenant_infras {
  id UUID [pk]
  name varchar(255)
  kafka_brokers "varchar(255)[]"
  schema_registry_url varchar(255)
  kafka_connect_url varchar(255)
  kms_key varchar(255)

  created_at timestamp
  updated_at timestamp
}

Table tags {
  id UUID [pk]
  tenant_id UUID [ref: > tenants.id]
  key varchar(255)
  value varchar(255)

  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
}

Table topics {
  id UUID [pk]
  tenant_id UUID [ref: > tenants.id]
  name varchar(255) // Kafka topic name, e.g., "tenant1.source1.collectionA"
  producer_type enum ('source', 'transformer')
  producer_id UUID // References sources.id or transformers.id based on producer_type
  created_at timestamp
  updated_at timestamp
}

Table sources {
  id UUID [pk]
  tenant_id UUID [ref: > tenants.id]
  name varchar(255)
  engine source_engine // Enum for source type (e.g., Kafka Connect)
  config JSONB // Connection details, streaming settings
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
}

Table source_outputs {
  id UUID [pk]
  source_id UUID [ref: > sources.id]
  topic_id UUID [ref: > topics.id] // Topic this collection streams to
  database_name VARCHAR(255)
  group_name VARCHAR(255)
  name VARCHAR(255)
  config JSONB // Streaming-specific config
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (source_id)
  }
}

Table transformers {
  id UUID [pk]
  tenant_id UUID [ref: > tenants.id]
  name varchar(255)
  config JSONB // Flink job config, transformation logic
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
}

Table transformer_inputs {
  id UUID [pk]
  transformer_id UUID [ref: > transformers.id]
  topic_id UUID [ref: > topics.id] // Output topic produced by transformer
  config JSONB // Output-specific config
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (transformer_id)
  }
}

Table transformer_outputs {
  id UUID [pk]
  transformer_id UUID [ref: > transformers.id]
  topic_id UUID [ref: > topics.id] // Output topic produced by transformer
  config JSONB // Output-specific config
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (transformer_id)
  }
}

Table destinations {
  id UUID [pk]
  tenant_id UUID [ref: > tenants.id]
  name varchar(255)
  engine destination_engine // Enum for destination type
  config JSONB // Connection details, write settings
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
}

Table destination_inputs {
  id UUID [pk]
  destination_id UUID [ref: > destinations.id]
  database_name VARCHAR(255)
  group_name VARCHAR(255)
  name VARCHAR(255)
  config JSONB // Collection-specific config
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (destination_id)
  }
}

Table pipelines {
  id UUID [pk]
  tenant_id UUID [ref: > tenants.id]
  name varchar(255)
  source_id UUID [ref: > sources.id]
  destination_id UUID [ref: > destinations.id]
  config JSONB // Pipeline-wide settings
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
}

Table pipeline_transformers {
  id UUID [pk]
  pipeline_id UUID [ref: > pipelines.id]
  transformer_id UUID [ref: > transformers.id]
  sequence int // Order in pipeline (1, 2, 3, ...)
  config JSONB // Transformer-specific pipeline config
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (pipeline_id, sequence) [unique] // Ensures unique order per pipeline
  }
}

Table pipeline_transformer_inputs {
  id UUID [pk]
  pipeline_transformer_id UUID [ref: > pipeline_transformers.id]
  topic_id UUID [ref: > topics.id] // Input topic from previous stage
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (pipeline_transformer_id)
  }
}

Table pipeline_destination_inputs {
  id UUID [pk]
  pipeline_id UUID [ref: > pipelines.id]
  topic_id UUID [ref: > topics.id] // Input topic from last transformer
  destination_input_id UUID [ref: > destination_inputs.id] // Target collection
  created_by_user_id UUID [ref: > users.id]
  updated_by_user_id UUID [ref: > users.id]
  created_at timestamp
  updated_at timestamp
  indexes {
    (pipeline_id)
  }
}
