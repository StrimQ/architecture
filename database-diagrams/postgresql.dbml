enum tier {
  free_trial [note: 'Free Trial tier will get their infras data wiped after 30 days']
  bronze
  silver
  gold
  platinum [note: 'Platinum tier will get their own dedicated infra']
}

Table tenants {
  tenant_id UUID
  name varchar(255)
  domain varchar(255)
  tier tier
  infra_id UUID

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id) [pk]
    (infra_id) [ref: > tenant_infras.tenant_infra_id]
  }
}

Table users {
  user_id UUID

  created_at timestamp
  updated_at timestamp

  indexes {
    (user_id) [pk]
  }
}

Table tenant_users {
  tenant_id UUID
  user_id UUID

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, user_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
    (user_id) [ref: > users.user_id]
  }
}

Table tenant_infras {
  tenant_infra_id UUID
  name varchar(255)
  kafka_brokers "varchar(255)[]"
  schema_registry_url varchar(255)
  kafka_connect_url varchar(255)
  kms_key varchar(255)

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_infra_id) [pk]
  }
}

Table tags {
  tenant_id UUID
  tag_id UUID
  key varchar(255)
  value varchar(255)

  created_by_user_id UUID
  updated_by_user_id UUID
  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, tag_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
    (created_by_user_id) [ref: > users.user_id]
    (updated_by_user_id) [ref: > users.user_id]
  }
}

enum topic_producer_type {
  source
  transformer
}

Table topics {
  tenant_id UUID
  topic_id UUID
  name varchar(255) // Kafka topic name, e.g., "tenant1.source1.collectionA"
  producer_type topic_producer_type
  producer_id UUID // References sources.source_id or transformers.transfomer_id based on producer_type

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, topic_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
  }
}

enum source_engine {
  mysql
  postgresql
}

Table sources {
  tenant_id UUID
  source_id UUID
  name varchar(255)
  engine source_engine
  config JSONB // Connection details, streaming settings

  created_by_user_id UUID
  updated_by_user_id UUID
  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, source_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
    created_by_user_id [ref: > users.id]
    updated_by_user_id [ref: > users.id]
  }
}

Table source_outputs {
  tenant_id UUID
  source_id UUID
  source_output_id UUID
  topic_id UUID
  database_name VARCHAR(255) // database
  group_name VARCHAR(255) // schema/namespace
  collection_name VARCHAR(255) // /collection/table
  config JSONB // Streaming-specific config

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, source_id, source_output_id) [pk]
    (tenant_id, source_id) [ref: > sources.(tenant_id, source_id)]
    (tenant_id, topic_id) [ref: > topics.(tenant_id, topic_id)]
  }
}

Table transformers {
  tenant_id UUID
  transfomer_id UUID
  name varchar(255)
  config JSONB // Flink job config, transformation logic

  created_by_user_id UUID
  updated_by_user_id UUID
  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, transfomer_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
    (created_by_user_id) [ref: > users.user_id]
    (updated_by_user_id) [ref: > users.user_id]
  }
}

Table transformer_inputs {
  tenant_id UUID
  transformer_id UUID
  transformer_input_id UUID // Input topic consumed by transformer
  topic_id UUID
  config JSONB // Input-specific config

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, transformer_id, transformer_input_id) [pk]
    (tenant_id, transformer_id) [ref: > transformers.(tenant_id, transfomer_id)]
    (tenant_id, topic_id) [ref: > topics.(tenant_id, topic_id)]
  }
}

Table transformer_outputs {
  tenant_id UUID
  transformer_id UUID
  transformer_output_id UUID
  topic_id UUID // Output topic produced by transformer
  config JSONB // Output-specific config

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, transformer_id, transformer_output_id) [pk]
    (tenant_id, transformer_id) [ref: > transformers.(tenant_id, transfomer_id)]
    (tenant_id, topic_id) [ref: > topics.(tenant_id, topic_id)]
  }
}

enum destination_engine {
  mysql
  postgresql
}

Table destinations {
  tenant_id UUID
  destination_id UUID
  name varchar(255)
  engine destination_engine // Enum for destination type
  config JSONB // Connection details, write settings

  created_by_user_id UUID
  updated_by_user_id UUID
  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, destination_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
    (created_by_user_id) [ref: > users.id]
    (updated_by_user_id) [ref: > users.id]
  }
}

Table pipelines {
  tenant_id UUID
  pipeline_id UUID
  name varchar(255)
  source_id UUID [null]
  destination_id UUID
  config JSONB // Pipeline-wide settings

  created_by_user_id UUID
  updated_by_user_id UUID
  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, pipeline_id) [pk]
    (tenant_id) [ref: > tenants.tenant_id]
    (tenant_id, source_id) [ref: > sources.(tenant_id, source_id)]
    (tenant_id, destination_id) [ref: > destinations.(tenant_id, destination_id)]
    (created_by_user_id) [ref: > users.user_id]
    (updated_by_user_id) [ref: > users.user_id]
  }
}

Table pipeline_transformers {
  tenant_id UUID
  pipeline_id UUID
  transformer_id UUID
  stage int // Order in pipeline (1, 2, 3, ...)
  config JSONB // Transformer-specific pipeline config

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, pipeline_id, transformer_id) [pk]
    (tenant_id, pipeline_id) [ref: > pipelines.(tenant_id, pipeline_id)]
    (tenant_id, transformer_id) [ref: > transformers.(tenant_id, transfomer_id)]
    (tenant_id, pipeline_id, stage) [unique] // Ensures unique order per pipeline
  }
}

Table pipeline_transformer_inputs {
  tenant_id UUID
  pipeline_id UUID
  transformer_id UUID
  topic_id UUID // Input topic from previous stage

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, pipeline_id, transfomer_id, topic_id) [pk]
    (tenant_id, pipeline_id, transformer_id) [ref: > pipeline_transformers.(tenant_id, pipeline_id, transformer_id)]
    (tenant_id, topic_id) [ref: > topics.(tenant_id, topic_id)]
  }
}

Table pipeline_destination_inputs {
  tenant_id UUID
  pipeline_id UUID
  topic_id UUID // Output topics from last transformer or source to destination as input

  created_at timestamp
  updated_at timestamp

  indexes {
    (tenant_id, pipeline_id, topic_id) [pk]
    (tenant_id, pipeline_id) [ref: > pipelines.(tenant_id, pipeline_id)]
    (tenant_id, topic_id) [ref: > topics.(tenant_id, topic_id)]
  }
}
